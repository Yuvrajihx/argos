import { exec } from 'node:child_process';
import { readFile, writeFile, access } from 'node:fs/promises';

let cached;
/**
 * Get the top level of the git repository.
 */ function getGitRepositoryPath() {
    if (!cached) {
        cached = new Promise((resolve)=>{
            exec("git rev-parse --show-toplevel", (error, stdout, stderr)=>{
                if (error) {
                    resolve(null);
                }
                if (stderr) {
                    resolve(null);
                }
                resolve(stdout.trim());
            });
        });
    }
    return cached;
}

// Cache the version to avoid reading the file multiple times.
const versionCache = new Map();
/**
 * Read the version from a package.json file.
 */ function readVersionFromPackage(pkgPath) {
    const readVersion = async ()=>{
        const { version } = JSON.parse(await readFile(pkgPath, "utf-8"));
        if (typeof version !== "string") {
            throw new Error("Invalid version");
        }
        return version;
    };
    if (!versionCache.has(pkgPath)) {
        versionCache.set(pkgPath, readVersion());
    }
    const fromCache = versionCache.get(pkgPath);
    if (!fromCache) {
        throw new Error("Invariant violation: version not in cache");
    }
    return fromCache;
}

/**
 * Get metadata path from screenshot path.
 */ function getMetadataPath(screenshotPath) {
    return screenshotPath + ".argos.json";
}

/**
 * Write screenshot metadata to disk.
 */ async function writeMetadata(screenshotPath, metadata) {
    await writeFile(getMetadataPath(screenshotPath), JSON.stringify(metadata));
}
/**
 * Read screenshot metadata from disk.
 * If not found, returns null.
 */ async function readMetadata(screenshotPath) {
    try {
        const metadata = await readFile(getMetadataPath(screenshotPath), "utf8");
        return JSON.parse(metadata);
    } catch (error) {
        if (error instanceof Error && "code" in error && error.code === "ENOENT") {
            return null;
        }
        throw new Error("Failed to read metadata", {
            cause: error
        });
    }
}

/**
 * Build a screenshot name from a test name and options.
 */ function getScreenshotName(name, options = {}) {
    let parts = [
        name
    ];
    if (options.viewportWidth) {
        parts.push(`vw-${options.viewportWidth}`);
    }
    return parts.join(" ");
}

/**
 * Get trace path from screenshot path.
 */ function getTracePath(screenshotPath) {
    return screenshotPath + ".pw-trace.zip";
}
/**
 * Get playwright trace from screenshot path.
 * If not found, returns null.
 */ async function getPlaywrightTracePath(screenshotPath) {
    try {
        const tracePath = getTracePath(screenshotPath);
        await access(tracePath);
        return tracePath;
    } catch  {
        return null;
    }
}

export { getGitRepositoryPath, getMetadataPath, getPlaywrightTracePath, getScreenshotName, readMetadata, readVersionFromPackage, writeMetadata };
